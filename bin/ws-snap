#!/bin/bash
# Snapshots root and /boot filesystems into /snapshots/{root,boot}/<label>
# as well as saves checksums and some stats into /snapshots/state git repo.
# Assumes root is on btrfs, /boot can be anything.
#
# Usage:
#   ws-snap init      to initialize /snapshots subvolume and directory structure
#   ws-snap <label>   to take a snapshot of current state

export LC_ALL=C
set -e

BASE_DIR=/snapshots
ZFS_BACKUP_DIR=/z/backup/ws-root

do_init() {
  apt install etckeeper git parallel btrfs-progs || true

  if ! btrfs subvolume show "${BASE_DIR}" >/dev/null 2>&1; then
    btrfs subvolume create "${BASE_DIR}"
  fi

  mkdir -p "${BASE_DIR}/root"
  mkdir -p "${BASE_DIR}/boot"
  mkdir -p "${BASE_DIR}/state"

  cd "${BASE_DIR}/state"
  if ! [[ -d .git ]]; then
    git init .
  fi
}

check_init() {
  if ! which etckeeper git parallel btrfs >/dev/null; then
    echo "Error: missing some of required packages: etckeeper git parallel btrfs-progs"
    exit 1
  fi

  if ! [[ -d "${BASE_DIR}/root" && -d "${BASE_DIR}/boot" && -d "${BASE_DIR}/state/.git" ]]; then
    echo "Error: ${BASE_DIR} is improperly set up"
    exit 1
  fi

  if ! btrfs subvolume show "${BASE_DIR}" >/dev/null 2>&1; then
    echo "Error: ${BASE_DIR} is not a subvolume"
    exit 1
  fi
}

do_snapshot() {
  LABEL="$1"
  ROOT_SNAPSHOT="${BASE_DIR}/root/$LABEL"
  BOOT_SNAPSHOT="${BASE_DIR}/boot/$LABEL"
  REPO_DIR="${BASE_DIR}/state"

  # Verify that label hasn't already been committed to state repository.
  cd "${REPO_DIR}"
  if git tag -l | fgrep -x "$LABEL" >/dev/null; then
    echo "Error: label '$LABEL' already exists in state repository"
    exit 1
  fi

  # Make sure changes in /etc are checked in, prune repository, tag with label.
  cd /etc
  if ! git status | grep 'nothing to commit, working tree clean' >/dev/null; then
    echo "/etc is dirty"
    etckeeper commit
    if ! git status | grep 'nothing to commit, working tree clean' >/dev/null; then
      echo "Error: /etc is still dirty"
      exit 1
    fi
  fi
  if git tag -l | fgrep -x "$LABEL" >/dev/null; then
    echo -n 'Removing previous tag in /etc: '
    git tag -d "$LABEL"
  fi
  git tag "$LABEL"
  git gc --prune=all --quiet

  # Some cleanup to reduce snapshot clutter
  cd "${REPO_DIR}"
  echo "Pre-snapshot cleanup"
  git gc --prune=all --quiet
  rm -rf /root/.parallel /root/.viminfo

  # Snapshot root filesystem.
  if [ -d "${ROOT_SNAPSHOT}" ]; then
    echo "Removing previous btrfs snapshot with same label: ${ROOT_SNAPSHOT}"
    btrfs subvolume delete "${ROOT_SNAPSHOT}"
    if [ -d "${ROOT_SNAPSHOT}" ]; then echo "Error: ${ROOT_SNAPSHOT} still exists"; exit 1; fi
  fi
  touch "/snapshot-label:${LABEL}"
  btrfs subvolume snapshot / "${ROOT_SNAPSHOT}"
  rm -f "/snapshot-label:${LABEL}"
  if ! [ -d "${ROOT_SNAPSHOT}" ]; then echo "Error: failed to create btrfs snapshot"; exit 1; fi
  if ! [ -f "${ROOT_SNAPSHOT}/etc/passwd" ]; then echo "Error: btrfs snapshot sanity check fail"; exit 1; fi

  # Snapshot boot filesystem.
  if [ -d "${BOOT_SNAPSHOT}" ]; then
    echo "Removing previous boot snapshot with same label: ${BOOT_SNAPSHOT}"
    rm -rf "${BOOT_SNAPSHOT}"
  fi
  cp -a /boot "${BOOT_SNAPSHOT}"
  if ! [ -f "${BOOT_SNAPSHOT}/grub/grub.cfg" ]; then echo "Error: boot snapshot sanity check fail"; exit 1; fi

  # Symlink snapshots into repository
  cd "${REPO_DIR}"
  rm -rf fs || true
  mkdir -p fs
  ln -s "${ROOT_SNAPSHOT}" ./fs/root
  ln -s "${BOOT_SNAPSHOT}" ./fs/boot

  # Generate derived stats
  cd "${REPO_DIR}"
  echo "Checksumming files"
  find fs/ fs/ -type f -print0 | \
      parallel --will-cite -X -0 -k -j '100%' sha256sum {} | \
      sed -e 's!^\([^ ]\+\)  fs/root/\(.*\)$!\1  /\2!' | \
      sed -e 's!^\([^ ]\+\)  fs/boot/\(.*\)$!\1  /boot/\2!' | \
      sort -k2,999 >sums
  rm -rf /root/.parallel

  find fs/boot/ fs/root/ -type f -perm /u+s,g+s -print0 | sort -z | xargs -0 -I{} -n 1 bash -c 'echo $(sha256sum "{}" | cut -d " " -f 1) $(ls -l "{}")' >fs.suid

  echo "Querying dpkg"
  (
    echo "dpkg --get-selections:"
    dpkg --get-selections | sort
    echo -e "\ndpkg -C / dpkg -V:"
    dpkg -C | sort; dpkg -V | sort;
    echo -e "\ndebsums -a:"
    debsums -a | sort | grep -v 'OK$'
  ) >fs.dpkg 2>&1 || true

  iptables -L >run.iptables
  netstat -an46p | sed -E -e 's|[0-9]+/([^ ]+) *$|xxx/\1|' >run.netstat
  pstree -al >run.pstree
  systemctl status | sed -E -e 's|^([- |`]+)([0-9]+ )|\1|' >run.systemctl

  git diff --stat HEAD

  read -p "Snapshot state written to working directory. Show diff [y/n]? " ANS
  if [[ "$ANS" == "y" ]] || [[ "$ANS" == "Y" ]]; then
    git diff
  fi

  read -p "Commit --edit [y/n]? " ANS
  if [[ "$ANS" == "y" ]] || [[ "$ANS" == "Y" ]]; then
    echo Committing
    git add fs fs.* run.* sums
    git commit -m "$LABEL" --edit
    git tag "$LABEL"
    git gc --prune=all --quiet

    if [[ -d "${ZFS_BACKUP_DIR}" ]]; then
      read -p "Archive to ${ZFS_BACKUP_DIR} [y/n]? " ANS
      if [[ "$ANS" == "y" ]] || [[ "$ANS" == "Y" ]]; then
        TARBALL="${ZFS_BACKUP_DIR}/${LABEL}.tar.xz"
        chmod 0400 "${ZFS_BACKUP_DIR}"
        echo "Archiving snapshot to ${TARBALL}"
        NCPU=$(cat /proc/cpuinfo  | grep ^processor | wc -l)
        XZCPU=$((NCPU >= 4 ? NCPU-2 : NCPU))
        tar -c "${REPO_DIR}" "${ROOT_SNAPSHOT}" "${BOOT_SNAPSHOT}" | xz -T$XZCPU -1 -vv >"${TARBALL}.tmp"
        mv "${TARBALL}.tmp" "${TARBALL}"
        chmod 0400 "${TARBALL}"
      fi
    fi
  fi

  echo Success
}

if [[ "$1" == "" ]]; then
  echo "Usage: $0 init|<label>"
  exit 1
elif [[ "$(whoami)" != "root" ]]; then
  echo "Warning: script must be run under root, rerunning under sudo."
  sudo "$(readlink -f -- "$0")" "$@"
elif [[ "$1" == "init" ]]; then
  do_init
else
  check_init
  do_snapshot "$1"
fi
